12.5

关于OpenGL进GPU渲染保存的矩阵及向量内存格式。

在做矩阵和向量的乘法的时候，由于矩阵和向量在内存中都保存成一排数据，不包含行列信息，因此我们需要人为规定在shader计算的时候对矩阵或者对向量做一个转置，也就是矩阵是解释成若干个行向量乘以列向量，还是行向量去乘以矩阵的若干个列向量。

```text
[1   2   3   4]      [ x,
[5   6   7   8]  *     y, 
[9  10  11  12]        z,
[13 14  15  16]        w ]
```

openGL中采用的规则是行矩阵乘列向量。为了实现这一点，规定了输入内存的数据都按行排列逐个存储，因此输入的向量是行向量，矩阵也从左到右从上到下拉成一行保存。在输入进来后对矩阵和向量都做一个转置，那么行向量就变成了列向量，为了让矩阵转置过后为行矩阵形式，在CPU端保存的矩阵要以列矩阵的形式保存，即对一个二维矩阵数组m\[n][n],第一维要存储列，第二维存储行，也就是说对上面的例子，矩阵在CPU内存中的排列为1,5,9,13,2,6,10,14,3,7,11,15，4，8,12,16，向量在内存的排列为x,y,z,w时，再传入GPU，两者经过转置才能计算正确。

为此第三方的glm库的mat4*4，默认就是采取先列后行的矩阵存储，在传入gpu的时候就不用用户自己转置了。但是这也带来了一定的问题，由于先列后行的矩阵相当于是进行了转置，glm在内部实现的矩阵累乘时候又仍然是左乘矩阵，那么如果按照预期的基本变换顺序叠加，其结果实际上是在按预期的逆序叠加基本变换，再取转置送入GPU端。以下面这个乘法为例：

想要将一个点p先绕y轴旋转90°，再绕x轴旋转-90°（默认逆时针，右手定则方向）,矩阵表示如下：
$$
R_y=\left[ \begin{matrix} 0& 0& 1& 0\\ 0& 1& 0& 0 \\-1& 0& 0& 0 \\ 0& 0& 0& 1 \end{matrix} \right],表示绕y轴旋转90°\\
R_x=\left[ \begin{matrix} 1& 0& 0& 0\\ 0& 0& 1& 0 \\0& -1& 0& 0 \\ 0& 0& 0& 1 \end{matrix} \right],表示绕x轴旋转-90°\\
\bold p=(1,1,0)\\
$$
正常的矩阵变换结果：
$$
R_xR_y=\left[ \begin{matrix} 0& 0& 1& 0\\ -1& 0& 0& 0 \\0& -1& 0& 0 \\ 0& 0& 0& 1 \end{matrix} \right]\\
R_xR_y\bold p=(0,-1,-1)
$$
这样的结果是正确的，由于GPU端要求CPU输入矩阵的转置，我们最终应该保存$(R_xR_y)^T$。

但是如果使用GLM库，$R_x$被存成了$R_x^T$,$R_y$同理，并仍然保持左乘矩阵，结果会是这样：
$$
R_x^TR_y^T=(R_yR_x)^T=\left[ \begin{matrix} 0& -1& 0& 0\\ 0& 0& 1& 0 \\-1& 0& 0& 0 \\ 0& 0& 0& 1 \end{matrix} \right]^T
$$
发现和最终想要保存的结果$(R_xR_y)^T$完全不一样，或者说矩阵叠加顺序刚好逆了过来。

结论：使用glm库glm::rotate、scale、translate的时候，只能倒着叠加。并且由于rotate内部实现将所绕轴和角度转化为旋转矩阵时，内部保存形式还是以转置的排列保存，所以矩阵输入必须也是转置的形式，也就是说glm库内部的矩阵都是按转置保存的，即使自己将矩阵转置回去按顺序叠加也没有用。



todo list：

封装model基本变换，将固定的部分先算好一个矩阵，然后自己定三个可变的RTS矩阵，如R=rotate(mat4(1.0),angle,axis);然后自己去乘在右边就行。todo；层级关系的transform变换。

增加fps计算。

写phong材质，固有色材质，pbr环境材质。

将mvp、mesh、material封装成一个RenderObject。

考虑一下怎么添加灯光？



2020.12.6 glm另一个坑，乘法运算符*如mat4 m=r1\*r2,实际上是r1左乘上r2，真的弱智。



opengl渲染文字：

固定管线下可以用glGenLists+wglbitmapCharacter系统函数生成图片纹理。或者用glut库的glbitmapcharacter生成固定大小和字体的文字。

核心管线下只能生成文字的纹理，然后将文字渲染到一个个小正方体块上。详见：

https://blog.csdn.net/yulinxx/article/details/55548559?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control

完成了model封装，通过Transform类。

完成了phong材质、固有色材质、pbr环境材质。

fps计算现在只能输出到屏幕，现代管线画文字好难。

todo：

fps以图片纹理展示到画面。

保存pbr环境贴图，有关纹理读取与保存。 finished。

灯光添加。

renderobject添加。

阴影计算添加。



2020.12.7

关于读入纹理是否要翻转的问题。

结论：2d纹理要翻转，cubemap不用。或者说用uv坐标采样的就要翻转，用三维位置坐标采样的就不用。

原因：opengl要求y轴向上，但图片的y轴向下，导致uv坐标也对应的是从上到下，这时候需要翻转。但是cubemap是用三维位置坐标采样的，不涉及uv坐标，所以纹理读进来的不用翻转。

today work：完成了纹理保存和读取。但是prefilter的mipmap的保存还没完成，本来想保存0级然后读取时genmipmap，发现效果完全不一样。



2020.12.8

解决了manual cubemap mipmap的加载问题。直接去翻了opengl的wiki才找到问题。

首先问题的来源在于ibl的prefilter cubemap根据粗糙度参数人工生成了多级的mipmap，因为这里生成的时候是加入了粗糙度参数，因此无论是原始生成还是后续载入都不能用自动生成mipmap的api generatemipmap()。

加载的时候首先在要在glteximage2d将图像数据传入gpu前，设置好glparameteri的GL_TEXTURE_BASE_LEVEL和MAX_LEVEL,再对glteximage2d的mipmaplevel参数进行设置才会有效。另外下面两句代码也要设置

```
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```

主要是min_filter中得设置mipmap的插值方式，让mipmap level之间能有插值。

https://www.khronos.org/opengl/wiki/Common_Mistakes



第二个问题的lut的2d纹理保存写出时要记得翻转，使得uv纹理坐标能和以左上为原点的图片坐标系对齐。

对比读取预处理纹理和每次重复预处理的时间，读取纹理减少了大概0.8s，可能是自己电脑gpu太好了。



2020.12.12

完成了fps文本渲染



2020.12.13

加入了renderobject和scene类，model继承renderobject，模型包含有多个renderobject，一个ro对应一个mesh，scene存储整个场景的renderobjectlist。

todo:transform树。



2020.12.15

完成了场景的树状结构和transform树的递归相乘。注意从transform中取出model矩阵获得的是model的转置（为了送入gpu方便），在各个model累乘的过程中要逆序相乘。



2020.12.19

add normal map



2020.12.21 

一个很严重的问题查了一天，之前写的pbr贴图预处理部分失效了。

问题一出在opengl状态机的设置上，由于加了文字渲染需要开启透明混合，但是prefilter和lut贴图渲染的时候如果开着透明混合会全是黑色，因此要在文字渲染的模块单独开关。

问题二出在envmap莫名其妙堆损坏，查了半天是mesh类中的material智能指针泄漏了，但是并不知道哪里出了问题，去问问别人。



2020.12.22

在孙老板的帮助下debug了一上午解决了智能指针悬空泄漏的问题。

```c++
unsigned int SkyboxMaterial::genEnvmap(const string& equirectangularPath) {

	MVPTransform* mvp = GenMVP();
	BufferElement * be = BufferManager::genBindFRBOBuffer(size, size);
	Shader equirectangularToCubemapShader("./shader/cube_generator.vs", "./shader/cube_generator.fs");
	Texture hdr = TextureLoader::loadTexture2D(equirectangularPath.c_str(),
		"equirectangularMap",
		GL_FLOAT,
		false,
		GL_CLAMP_TO_EDGE
		);
	//cout << glGetError() << endl;
	unsigned int envCubemap = TextureLoader::genEmptyTextureCubeMap(size, size, GL_RGB, GL_FLOAT, GL_CLAMP_TO_EDGE, false);
	// ----------------------------------------------------------------------------------------------
	// pbr: convert HDR equirectangular environment map to cubemap equivalent
	// ----------------------------------------------------------------------
	glViewport(0, 0, size, size); // don't forget to configure the viewport to the capture dimensions.
	glBindFramebuffer(GL_FRAMEBUFFER, be->FBO);
	shared_ptr<Mesh> cube = Geometry::createCube();
	//cout << cube.material.use_count() << endl;
	cube->material->BindShader(equirectangularToCubemapShader);
	//cout << cube.material.use_count() << endl;
	cube->addTexture(hdr.id, hdr.name_in_shader, GL_TEXTURE_2D);
	//cout << cube.material.use_count() << endl;
	for (unsigned int i = 0; i < 6; ++i)
	{
		cube->setMVP(mvp[i]);
		//cout << cube->material.use_count() << endl;
		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, envCubemap, 0);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		cube->draw();
	}
	//cout << cube->material.use_count() << endl;
	glBindFramebuffer(GL_FRAMEBUFFER, 0);
	return envCubemap;

}
```

问题代码是这里函数返回的时候报错堆损坏，根本原因其实不是mesh类中的material智能指针的问题，问题在于这里的shader实例对象是个临时的栈对象，我把它的实例对象bind给了material，这里bindshader函数将shader实例取地址并赋给了material类中的shader智能指针。

然后问题就是函数结束时函数内的shader栈临时对象首先释放掉了，同时函数内的cube智能指针对象也释放掉了，cube实例的引用-1变为0，因此释放cube堆对象，cube堆对象中有material智能指针，material智能指针释放掉后引用为0，释放material堆对象，释放material堆对象会释放里面的shader智能指针，shader智能指针的引用减为0也要释放，但是shader智能指针被我用来指向一个栈对象了，这个栈对象已经先行释放了，结果就是导致重复释放炸掉。

**结论：**

1.智能指针是用来管理堆对象的，管理栈对象会很危险。

2.不要把一个函数设计成接口是实例对象，但把它赋给一个智能指针，就像我这里的bindshader是一个很错误的行为。

3.智能指针的初始化，要么new一个，要么把一个已经有指向的智能指针赋给另一个，增加引用。



关于brdfLUT的hdr图打开显示很亮、和learnopengl给出的标准png图不同的问题。

png图处于sRGB空间，出来的时候经过encode，纹理读入后无需处理经过显示器decode抵消，在opengl中获得和外部看到一样的效果。

hdr图处于线性空间，纹理读入后不处理经过显示器decode乘2.2次幂得到sRGB空间，在opengl里显示出来和sRGB空间的png图一样，但是解析hdr格式的图像软件好像自己做了一次encode，使得在屏幕上显示出来的是hdr线性空间的真值而非平时常见的sRGB空间的值，所以hdr图显得稍亮。



解决了地板会遮挡fps文字渲染的问题，同时对空间矩阵的变换过程有了更深的理解。

opengl的gl_position内置变量代表的是clip space中的坐标这个毫无疑问，但是clip space是什么，坐标范围又是什么？

这要从mvp三个矩阵看起，一开始的顶点坐标是模型空间的坐标，乘完model后的坐标是世界空间中的坐标，model完成模型坐标->世界坐标。

乘完view后的坐标是观察空间中的坐标，也就是以相机为坐标原点的坐标系。

乘完projection后从观察空间变换到裁剪空间，也就是将我们为摄像机设定的可见区域（平截头体）的坐标映射到一个标准设备坐标NDC上，**这个NDC就是裁剪空间的坐标范围。**

也就是说gl_position设置的有效坐标范围是NDC的范围，也就是（-1，-1，-1）->(1,1,1)的立方体空间，我们在乘完mvp矩阵后的坐标范围能够保证在这个区间内。

回到fps文字渲染的问题，这里给fps文字渲染设置的mvp代码为：

```
MVPTransform(mat4(1.0), mat4(1.0), glm::ortho(0.0f,(float) SCR_WIDTH, 0.0f, (float)SCR_HEIGHT)）
```

projection为正交矩阵，没有设置近平面和远平面则默认将所有对象摊平到NDC坐标z=0的那个平面上，因此text vertex shader的clipPos.z=0.0。

而地面的projection设置是一个near为0.1 far为100.0的平截头体，而地面mesh的模型坐标范围是-10到10，因此变换到NDC后的z值明显小于0，尽管从平截头体映射到深度缓冲的z和NDC中的z值不完全相同，但很明显一定会有部分地面挡住文字。

解决方法：直接将gl_position的z值置为-1.0,或者在fragment shader中设置gl_FragDepth=0.0.

todo：加light和shadow，同时搞清楚NDC和深度缓冲的z值区别。

区别就是：深度缓冲的z*2-1=NDC的z。NDC的z在projection矩阵应用时变得非线性化。



2020.12.24

为树状场景结构的环形引用替换了weak_ptr，并增加enable_shared_from_this的继承改善了shared from this的问题。注意一定不能使用shared_ptr<this>进行返回，这样的做法是增加一个指向同一个对象但是和原先不共享引用数目的智能指针，析构的时候两个智能指针都会对同一对象进行重复析构！

同时shared_from_this的使用要注意可能会报错bad weak_ptr，这种原因可能是在类对象还没初始化完成时，就在构造函数中有调用shared_from_this，由于构造函数还未完成没有产生指向自身的weak_ptr，调用shared_from_this自然会报错bad weak_ptr（shared from this的本质就是保存一个指向自身的weak ptr，调用时转为shared_ptr返回）



2021.1.2

之前已经完成了点光源和方向光，现在增加了方向光的shadowmap，结果感觉有点问题，如果转动光源shadow会慢慢消失。



头文件循环包含问题的解决方案：

eg: 

```c++
//a.h
#include "b.h"

//b.h
class a;

//b.cpp
#include "a.h"
```

未解决：textureloader里无法添加static 成员变量，会出现重定义，不知道为什么。